// Code generated by mockery v2.0.0. DO NOT EDIT.

package mocks

import (
	context "context"

	confluent_kafka_gokafka "github.com/confluentinc/confluent-kafka-go/kafka"

	mock "github.com/stretchr/testify/mock"
)

// Producer is an autogenerated mock type for the Producer type
type Producer struct {
	mock.Mock
}

// AbortTransaction provides a mock function with given fields: ctx
func (_m *Producer) AbortTransaction(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BeginTransaction provides a mock function with given fields:
func (_m *Producer) BeginTransaction() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *Producer) Close() {
	_m.Called()
}

// CommitTransaction provides a mock function with given fields: ctx
func (_m *Producer) CommitTransaction(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Events provides a mock function with given fields:
func (_m *Producer) Events() chan confluent_kafka_gokafka.Event {
	ret := _m.Called()

	var r0 chan confluent_kafka_gokafka.Event
	if rf, ok := ret.Get(0).(func() chan confluent_kafka_gokafka.Event); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan confluent_kafka_gokafka.Event)
		}
	}

	return r0
}

// Flush provides a mock function with given fields: timeoutMs
func (_m *Producer) Flush(timeoutMs int) int {
	ret := _m.Called(timeoutMs)

	var r0 int
	if rf, ok := ret.Get(0).(func(int) int); ok {
		r0 = rf(timeoutMs)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetFatalError provides a mock function with given fields:
func (_m *Producer) GetFatalError() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetMetadata provides a mock function with given fields: topic, allTopics, timeoutMs
func (_m *Producer) GetMetadata(topic *string, allTopics bool, timeoutMs int) (*confluent_kafka_gokafka.Metadata, error) {
	ret := _m.Called(topic, allTopics, timeoutMs)

	var r0 *confluent_kafka_gokafka.Metadata
	if rf, ok := ret.Get(0).(func(*string, bool, int) *confluent_kafka_gokafka.Metadata); ok {
		r0 = rf(topic, allTopics, timeoutMs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*confluent_kafka_gokafka.Metadata)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*string, bool, int) error); ok {
		r1 = rf(topic, allTopics, timeoutMs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitTransactions provides a mock function with given fields: ctx
func (_m *Producer) InitTransactions(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Len provides a mock function with given fields:
func (_m *Producer) Len() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Logs provides a mock function with given fields:
func (_m *Producer) Logs() chan confluent_kafka_gokafka.LogEvent {
	ret := _m.Called()

	var r0 chan confluent_kafka_gokafka.LogEvent
	if rf, ok := ret.Get(0).(func() chan confluent_kafka_gokafka.LogEvent); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan confluent_kafka_gokafka.LogEvent)
		}
	}

	return r0
}

// OffsetsForTimes provides a mock function with given fields: times, timeoutMs
func (_m *Producer) OffsetsForTimes(times []confluent_kafka_gokafka.TopicPartition, timeoutMs int) ([]confluent_kafka_gokafka.TopicPartition, error) {
	ret := _m.Called(times, timeoutMs)

	var r0 []confluent_kafka_gokafka.TopicPartition
	if rf, ok := ret.Get(0).(func([]confluent_kafka_gokafka.TopicPartition, int) []confluent_kafka_gokafka.TopicPartition); ok {
		r0 = rf(times, timeoutMs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]confluent_kafka_gokafka.TopicPartition)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]confluent_kafka_gokafka.TopicPartition, int) error); ok {
		r1 = rf(times, timeoutMs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Produce provides a mock function with given fields: msg, deliveryChan
func (_m *Producer) Produce(msg *confluent_kafka_gokafka.Message, deliveryChan chan confluent_kafka_gokafka.Event) error {
	ret := _m.Called(msg, deliveryChan)

	var r0 error
	if rf, ok := ret.Get(0).(func(*confluent_kafka_gokafka.Message, chan confluent_kafka_gokafka.Event) error); ok {
		r0 = rf(msg, deliveryChan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProduceChannel provides a mock function with given fields:
func (_m *Producer) ProduceChannel() chan *confluent_kafka_gokafka.Message {
	ret := _m.Called()

	var r0 chan *confluent_kafka_gokafka.Message
	if rf, ok := ret.Get(0).(func() chan *confluent_kafka_gokafka.Message); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan *confluent_kafka_gokafka.Message)
		}
	}

	return r0
}

// Purge provides a mock function with given fields: flags
func (_m *Producer) Purge(flags int) error {
	ret := _m.Called(flags)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(flags)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// QueryWatermarkOffsets provides a mock function with given fields: topic, partition, timeoutMs
func (_m *Producer) QueryWatermarkOffsets(topic string, partition int32, timeoutMs int) (int64, int64, error) {
	ret := _m.Called(topic, partition, timeoutMs)

	var r0 int64
	if rf, ok := ret.Get(0).(func(string, int32, int) int64); ok {
		r0 = rf(topic, partition, timeoutMs)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 int64
	if rf, ok := ret.Get(1).(func(string, int32, int) int64); ok {
		r1 = rf(topic, partition, timeoutMs)
	} else {
		r1 = ret.Get(1).(int64)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, int32, int) error); ok {
		r2 = rf(topic, partition, timeoutMs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SendOffsetsToTransaction provides a mock function with given fields: ctx, offsets, consumerMetadata
func (_m *Producer) SendOffsetsToTransaction(ctx context.Context, offsets []confluent_kafka_gokafka.TopicPartition, consumerMetadata *confluent_kafka_gokafka.ConsumerGroupMetadata) error {
	ret := _m.Called(ctx, offsets, consumerMetadata)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []confluent_kafka_gokafka.TopicPartition, *confluent_kafka_gokafka.ConsumerGroupMetadata) error); ok {
		r0 = rf(ctx, offsets, consumerMetadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetOAuthBearerToken provides a mock function with given fields: oauthBearerToken
func (_m *Producer) SetOAuthBearerToken(oauthBearerToken confluent_kafka_gokafka.OAuthBearerToken) error {
	ret := _m.Called(oauthBearerToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(confluent_kafka_gokafka.OAuthBearerToken) error); ok {
		r0 = rf(oauthBearerToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetOAuthBearerTokenFailure provides a mock function with given fields: errstr
func (_m *Producer) SetOAuthBearerTokenFailure(errstr string) error {
	ret := _m.Called(errstr)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(errstr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// String provides a mock function with given fields:
func (_m *Producer) String() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// TestFatalError provides a mock function with given fields: code, str
func (_m *Producer) TestFatalError(code confluent_kafka_gokafka.ErrorCode, str string) confluent_kafka_gokafka.ErrorCode {
	ret := _m.Called(code, str)

	var r0 confluent_kafka_gokafka.ErrorCode
	if rf, ok := ret.Get(0).(func(confluent_kafka_gokafka.ErrorCode, string) confluent_kafka_gokafka.ErrorCode); ok {
		r0 = rf(code, str)
	} else {
		r0 = ret.Get(0).(confluent_kafka_gokafka.ErrorCode)
	}

	return r0
}
